<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>fstrm: fstrm_io</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fstrm
   &#160;<span id="projectnumber">0.2.0-pre</span>
   </div>
   <div id="projectbrief">Frame Streams implementation in C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__fstrm__io.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fstrm_io</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The <code>fstrm_io</code> interface creates a background I/O thread which writes Frame Streams encapsulated data frames into an output stream specified by an <a class="el" href="group__fstrm__writer.html">fstrm_writer</a>. Parameters used to configure the I/O thread are passed through an <code>fstrm_io_options</code> object.</p>
<p>A number of parameters for configuring an individual <code>fstrm_io</code> object can be provided through an <code>fstrm_io_options</code> object. Most of these parameters are performance knobs which have reasonable defaults and will generally not need to be configured by most <code>fstrm_io</code> users. However, there is no default for the <code>writer</code> parameter, which specifies a concrete implementation for writing Frame Streams content to an output stream (such as <a class="el" href="group__fstrm__file__writer.html">fstrm_file_writer</a> or <a class="el" href="group__fstrm__unix__writer.html">fstrm_unix_writer</a>). This parameter must be set with the <a class="el" href="group__fstrm__io.html#gaa4c688613ff342028d5e48ed68bd8d13" title="Set the writer implementation to use for the output stream. ">fstrm_io_options_set_writer()</a> function. Custom writers may be implemented through the <a class="el" href="group__fstrm__writer.html">fstrm_writer</a> interface.</p>
<p><code>fstrm_io</code> users may also want to use the <a class="el" href="group__fstrm__io.html#ga2d59f9ac663390e5f8e362bb9b42c782" title="Set the content_type option. ">fstrm_io_options_set_content_type()</a> function to embed a "Content Type" value in the Frame Streams output. This value can be used to describe the encoding of data frames. For instance, if data frames are being encoded using Protocol Buffers, the Frame Streams "Content Type" might specify the package-qualified name of a top-level Protocol Buffers message type. (E.g., <code>dnstap</code> uses a Content Type of <code>"protobuf:dnstap.Dnstap"</code>.) Or, if data frames are encoded with XML, the Frame Streams "Content Type" might specify a URL to an XML schema. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8884c56475e2f106859a09302dbb0034"><td class="memItemLeft" align="right" valign="top">struct fstrm_io *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#ga8884c56475e2f106859a09302dbb0034">fstrm_io_init</a> (const struct fstrm_io_options *opt, char **err)</td></tr>
<tr class="memdesc:ga8884c56475e2f106859a09302dbb0034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <code>fstrm_io</code> object.  <a href="#ga8884c56475e2f106859a09302dbb0034">More...</a><br/></td></tr>
<tr class="separator:ga8884c56475e2f106859a09302dbb0034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga143b807ae146b56f6f3b759f40220fd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#ga143b807ae146b56f6f3b759f40220fd5">fstrm_io_destroy</a> (struct fstrm_io **io)</td></tr>
<tr class="memdesc:ga143b807ae146b56f6f3b759f40220fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an <code>fstrm_io</code> object.  <a href="#ga143b807ae146b56f6f3b759f40220fd5">More...</a><br/></td></tr>
<tr class="separator:ga143b807ae146b56f6f3b759f40220fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f7dc2ffd79c36977972050fca55c5a1"><td class="memItemLeft" align="right" valign="top">struct fstrm_queue *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#ga5f7dc2ffd79c36977972050fca55c5a1">fstrm_io_get_queue</a> (struct fstrm_io *fio)</td></tr>
<tr class="memdesc:ga5f7dc2ffd79c36977972050fca55c5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an <code>fstrm_queue</code> object for submitting data frames to the <code>fstrm_io</code> object.  <a href="#ga5f7dc2ffd79c36977972050fca55c5a1">More...</a><br/></td></tr>
<tr class="separator:ga5f7dc2ffd79c36977972050fca55c5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4287d59ce3a396c5725e55645b1db66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__constants.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#gab4287d59ce3a396c5725e55645b1db66">fstrm_io_submit</a> (struct fstrm_io *fio, struct fstrm_queue *fq, void *buf, size_t len, void(*free_func)(void *buf, void *free_data), void *free_data)</td></tr>
<tr class="memdesc:gab4287d59ce3a396c5725e55645b1db66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a data frame to the background I/O thread.  <a href="#gab4287d59ce3a396c5725e55645b1db66">More...</a><br/></td></tr>
<tr class="separator:gab4287d59ce3a396c5725e55645b1db66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb33a015a20c5b70966bb45b5afb9923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#gaeb33a015a20c5b70966bb45b5afb9923">fstrm_free_wrapper</a> (void *buf, void *free_data)</td></tr>
<tr class="memdesc:gaeb33a015a20c5b70966bb45b5afb9923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for the system's <code>free()</code> function suitable for use as a callback to <a class="el" href="group__fstrm__io.html#gab4287d59ce3a396c5725e55645b1db66" title="Submit a data frame to the background I/O thread. ">fstrm_io_submit()</a>.  <a href="#gaeb33a015a20c5b70966bb45b5afb9923">More...</a><br/></td></tr>
<tr class="separator:gaeb33a015a20c5b70966bb45b5afb9923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57a03166e6cee802c6a8cce813cc106"><td class="memItemLeft" align="right" valign="top">struct fstrm_io_options *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#gab57a03166e6cee802c6a8cce813cc106">fstrm_io_options_init</a> (void)</td></tr>
<tr class="memdesc:gab57a03166e6cee802c6a8cce813cc106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <code>fstrm_io_options</code> object, which is needed by <a class="el" href="group__fstrm__io.html#ga8884c56475e2f106859a09302dbb0034" title="Initialize an fstrm_io object. ">fstrm_io_init()</a>.  <a href="#gab57a03166e6cee802c6a8cce813cc106">More...</a><br/></td></tr>
<tr class="separator:gab57a03166e6cee802c6a8cce813cc106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed60ee50b93a0779298e54dfdca40865"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#gaed60ee50b93a0779298e54dfdca40865">fstrm_io_options_destroy</a> (struct fstrm_io_options **fopt)</td></tr>
<tr class="memdesc:gaed60ee50b93a0779298e54dfdca40865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an <code>fstrm_io_options</code> object.  <a href="#gaed60ee50b93a0779298e54dfdca40865">More...</a><br/></td></tr>
<tr class="separator:gaed60ee50b93a0779298e54dfdca40865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf7c89cd378ba39a41218049165af0fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#gadf7c89cd378ba39a41218049165af0fc">fstrm_io_options_set_buffer_hint</a> (struct fstrm_io_options *fopt, unsigned buffer_hint)</td></tr>
<tr class="memdesc:gadf7c89cd378ba39a41218049165af0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code>buffer_hint</code> option.  <a href="#gadf7c89cd378ba39a41218049165af0fc">More...</a><br/></td></tr>
<tr class="separator:gadf7c89cd378ba39a41218049165af0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d59f9ac663390e5f8e362bb9b42c782"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#ga2d59f9ac663390e5f8e362bb9b42c782">fstrm_io_options_set_content_type</a> (struct fstrm_io_options *fopt, const void *buf, size_t len)</td></tr>
<tr class="memdesc:ga2d59f9ac663390e5f8e362bb9b42c782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code>content_type</code> option.  <a href="#ga2d59f9ac663390e5f8e362bb9b42c782">More...</a><br/></td></tr>
<tr class="separator:ga2d59f9ac663390e5f8e362bb9b42c782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e679938f977674856537ff2efcdc7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#gaf4e679938f977674856537ff2efcdc7a">fstrm_io_options_set_flush_timeout</a> (struct fstrm_io_options *fopt, unsigned flush_timeout)</td></tr>
<tr class="memdesc:gaf4e679938f977674856537ff2efcdc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code>flush_timeout</code> option.  <a href="#gaf4e679938f977674856537ff2efcdc7a">More...</a><br/></td></tr>
<tr class="separator:gaf4e679938f977674856537ff2efcdc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee260467817a459aff1cfcc82ade130e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#gaee260467817a459aff1cfcc82ade130e">fstrm_io_options_set_iovec_size</a> (struct fstrm_io_options *fopt, unsigned iovec_size)</td></tr>
<tr class="memdesc:gaee260467817a459aff1cfcc82ade130e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code>iovec_size</code> option.  <a href="#gaee260467817a459aff1cfcc82ade130e">More...</a><br/></td></tr>
<tr class="separator:gaee260467817a459aff1cfcc82ade130e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab932d83d6cdebada2a85c491ffd0dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#gaeab932d83d6cdebada2a85c491ffd0dd">fstrm_io_options_set_num_queues</a> (struct fstrm_io_options *fopt, unsigned num_queues)</td></tr>
<tr class="memdesc:gaeab932d83d6cdebada2a85c491ffd0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code>num_queues</code> option.  <a href="#gaeab932d83d6cdebada2a85c491ffd0dd">More...</a><br/></td></tr>
<tr class="separator:gaeab932d83d6cdebada2a85c491ffd0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49323ea976e7ed36c47ab488e3300fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#ga49323ea976e7ed36c47ab488e3300fb6">fstrm_io_options_set_queue_length</a> (struct fstrm_io_options *fopt, unsigned queue_length)</td></tr>
<tr class="memdesc:ga49323ea976e7ed36c47ab488e3300fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code>queue_length</code> option.  <a href="#ga49323ea976e7ed36c47ab488e3300fb6">More...</a><br/></td></tr>
<tr class="separator:ga49323ea976e7ed36c47ab488e3300fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga968bb756b3f5adc0bd0a03fd6e99e4e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#ga968bb756b3f5adc0bd0a03fd6e99e4e8">fstrm_io_options_set_queue_model</a> (struct fstrm_io_options *fopt, <a class="el" href="group__constants.html#ga45b55e31b0b151b2990fe86c71a3ca48">fstrm_queue_model</a> queue_model)</td></tr>
<tr class="memdesc:ga968bb756b3f5adc0bd0a03fd6e99e4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code>queue_model</code> option.  <a href="#ga968bb756b3f5adc0bd0a03fd6e99e4e8">More...</a><br/></td></tr>
<tr class="separator:ga968bb756b3f5adc0bd0a03fd6e99e4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a70e58bc3fcd6553d3e5852fbd79be3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#ga7a70e58bc3fcd6553d3e5852fbd79be3">fstrm_io_options_set_queue_notify_threshold</a> (struct fstrm_io_options *fopt, unsigned queue_notify_threshold)</td></tr>
<tr class="memdesc:ga7a70e58bc3fcd6553d3e5852fbd79be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code>queue_notify_threshold</code> option.  <a href="#ga7a70e58bc3fcd6553d3e5852fbd79be3">More...</a><br/></td></tr>
<tr class="separator:ga7a70e58bc3fcd6553d3e5852fbd79be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad810160c9a4b6f970f0399df533d040d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#gad810160c9a4b6f970f0399df533d040d">fstrm_io_options_set_reconnect_interval</a> (struct fstrm_io_options *fopt, unsigned reconnect_interval)</td></tr>
<tr class="memdesc:gad810160c9a4b6f970f0399df533d040d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code>reconnect_interval</code> option.  <a href="#gad810160c9a4b6f970f0399df533d040d">More...</a><br/></td></tr>
<tr class="separator:gad810160c9a4b6f970f0399df533d040d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c688613ff342028d5e48ed68bd8d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__io.html#gaa4c688613ff342028d5e48ed68bd8d13">fstrm_io_options_set_writer</a> (struct fstrm_io_options *fopt, const struct fstrm_writer *writer, const void *writer_options)</td></tr>
<tr class="memdesc:gaa4c688613ff342028d5e48ed68bd8d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code>writer</code> implementation to use for the output stream.  <a href="#gaa4c688613ff342028d5e48ed68bd8d13">More...</a><br/></td></tr>
<tr class="separator:gaa4c688613ff342028d5e48ed68bd8d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8884c56475e2f106859a09302dbb0034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fstrm_io* fstrm_io_init </td>
          <td>(</td>
          <td class="paramtype">const struct fstrm_io_options *&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an <code>fstrm_io</code> object. </p>
<p>This creates a background I/O thread which asynchronously writes data payloads submitted by other threads which call <a class="el" href="group__fstrm__io.html#gab4287d59ce3a396c5725e55645b1db66" title="Submit a data frame to the background I/O thread. ">fstrm_io_submit()</a>.</p>
<p><a class="el" href="group__fstrm__io.html#ga8884c56475e2f106859a09302dbb0034" title="Initialize an fstrm_io object. ">fstrm_io_init()</a> must receive an options object created by <a class="el" href="group__fstrm__io.html#gab57a03166e6cee802c6a8cce813cc106" title="Initialize an fstrm_io_options object, which is needed by fstrm_io_init(). ">fstrm_io_options_init()</a>, and this options object must specify an <a class="el" href="group__fstrm__writer.html">fstrm_writer</a> to use to write data frames into. See <a class="el" href="group__fstrm__io.html#gaa4c688613ff342028d5e48ed68bd8d13" title="Set the writer implementation to use for the output stream. ">fstrm_io_options_set_writer()</a>.</p>
<p>The options object used in the initialization of an <code>fstrm_io</code> object may be destroyed with <a class="el" href="group__fstrm__io.html#gaed60ee50b93a0779298e54dfdca40865" title="Destroy an fstrm_io_options object. ">fstrm_io_options_destroy()</a> after <a class="el" href="group__fstrm__io.html#ga8884c56475e2f106859a09302dbb0034" title="Initialize an fstrm_io object. ">fstrm_io_init()</a> returns.</p>
<p>This function performs sanity checking of the options specified via the <code>opt</code> parameter and will return an error string if any of these checks fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>I/O options, created by <a class="el" href="group__fstrm__io.html#gab57a03166e6cee802c6a8cce813cc106" title="Initialize an fstrm_io_options object, which is needed by fstrm_io_init(). ">fstrm_io_options_init()</a>. Must be non-NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Error string return pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>fstrm_io</code> context object which is non-NULL on success or NULL on failure. On failure, if <code>err</code> was non-NULL, <code>*err</code> will point to a malloc'd error string describing the reason for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga143b807ae146b56f6f3b759f40220fd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_io_destroy </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_io **&#160;</td>
          <td class="paramname"><em>io</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an <code>fstrm_io</code> object. </p>
<p>This signals the background I/O thread to flush or discard any queued data frames and deallocates any resources used internally. This function is synchronous and waits for the I/O thread to terminate before returning.</p>
<p>The <a class="el" href="group__fstrm__writer.html">fstrm_writer</a> used by the <code>fstrm_io</code> object will have its <code>destroy</code> method invoked by a call to <a class="el" href="group__fstrm__io.html#ga143b807ae146b56f6f3b759f40220fd5" title="Destroy an fstrm_io object. ">fstrm_io_destroy()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">io</td><td>Pointer to an <code>fstrm_io</code> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f7dc2ffd79c36977972050fca55c5a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fstrm_queue* fstrm_io_get_queue </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_io *&#160;</td>
          <td class="paramname"><em>fio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain an <code>fstrm_queue</code> object for submitting data frames to the <code>fstrm_io</code> object. </p>
<p><code>fstrm_queue</code> objects are child objects of their parent <code>fstrm_io</code> object and will be destroyed when <a class="el" href="group__fstrm__io.html#ga143b807ae146b56f6f3b759f40220fd5" title="Destroy an fstrm_io object. ">fstrm_io_destroy()</a> is called on the parent <code>fstrm_io</code> object.</p>
<p>This function is thread-safe and may be called simultaneously from any thread. For example, in a program which employs worker threads to handle requests, <a class="el" href="group__fstrm__io.html#ga5f7dc2ffd79c36977972050fca55c5a1" title="Obtain an fstrm_queue object for submitting data frames to the fstrm_io object. ">fstrm_io_get_queue()</a> may be called from a thread startup routine without synchronization.</p>
<p><code>fstrm_io</code> objects allocate a fixed total number of <code>fstrm_queue</code> objects at the time of a call to <a class="el" href="group__fstrm__io.html#ga8884c56475e2f106859a09302dbb0034" title="Initialize an fstrm_io object. ">fstrm_io_init()</a>. To adjust this number, use <a class="el" href="group__fstrm__io.html#gaeab932d83d6cdebada2a85c491ffd0dd" title="Set the num_queues option. ">fstrm_io_options_set_num_queues()</a>. This function will fail if it is called more than the number of times allowed by this option. By default, only one queue is initialized per <code>fstrm_io</code> object.</p>
<p>For optimum performance in a threaded program, each worker thread submitting data frames should have a dedicated <code>fstrm_queue</code> object. This allows each worker thread to have its own queue which is processed independently by the I/O thread. If the queue model for the <code>fstrm_io</code> object is set to <a class="el" href="group__constants.html#gga45b55e31b0b151b2990fe86c71a3ca48a013b7dfa4da6b8dec2d2f5af05292a2a" title="Single Producer, Single Consumer. ">FSTRM_QUEUE_MODEL_SPSC</a>, this avoids the need for synchronized access to the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fio</td><td><code>fstrm_io</code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>fstrm_queue</code> object which is non-NULL on success and NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gab4287d59ce3a396c5725e55645b1db66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__constants.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a> fstrm_io_submit </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_io *&#160;</td>
          <td class="paramname"><em>fio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct fstrm_queue *&#160;</td>
          <td class="paramname"><em>fq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *buf, void *free_data)&#160;</td>
          <td class="paramname"><em>free_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>free_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a data frame to the background I/O thread. </p>
<p>If successfully queued and the I/O thread has an active output stream opened, the data frame will be asynchronously written to the output stream.</p>
<p>When this function returns <a class="el" href="group__constants.html#ggad3cb32b083ff99d02ccfbc1a69823329a6c9f6b085d2d3479f30d175978355b54" title="Success. ">FSTRM_RES_SUCCESS</a>, responsibility for deallocating the data frame specified by the <code>buf</code> parameter passes to the <code>fstrm</code> library. The caller <b>MUST</b> ensure that the <code>buf</code> object remains valid after <a class="el" href="group__fstrm__io.html#gab4287d59ce3a396c5725e55645b1db66" title="Submit a data frame to the background I/O thread. ">fstrm_io_submit()</a> returns. The callback function specified by the <code>free_func</code> parameter will be invoked once the data frame is no longer needed by the <code>fstrm</code> library. For example, if the data frame is dynamically allocated, the caller may deallocate the data frame in the callback function.</p>
<p>As a convenience, if <code>buf</code> is allocated with the system's <code>malloc()</code>, <code>fstrm_free_wrapper</code> may be provided as the <code>free_func</code> parameter with the <code>free_data</code> parameter set to <code>NULL</code>. This will cause the system's <code>free()</code> to be invoked to deallocate <code>buf</code>.</p>
<p><code>free_func</code> may be NULL, in which case no callback function will be invoked to dispose of <code>buf</code>. This behavior may be useful if <code>buf</code> is a global, statically allocated object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fio</td><td><code>fstrm_io</code> object. </td></tr>
    <tr><td class="paramname">fq</td><td><code>fstrm_queue</code> object. </td></tr>
    <tr><td class="paramname">buf</td><td>Data frame bytes. </td></tr>
    <tr><td class="paramname">len</td><td>Number of data frame bytes in <code>buf</code>. </td></tr>
    <tr><td class="paramname">free_func</td><td>Callback function to deallocate the data frame. The <code>buf</code> and <code>free_data</code> parameters passed to this callback will be the same values originally supplied to <a class="el" href="group__fstrm__io.html#gab4287d59ce3a396c5725e55645b1db66" title="Submit a data frame to the background I/O thread. ">fstrm_io_submit()</a>. </td></tr>
    <tr><td class="paramname">free_data</td><td>Parameter to pass to <code>free_func</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FSTRM_RES_SUCCESS The data frame was successfully queued. </dd>
<dd>
FSTRM_RES_AGAIN The queue is full. </dd>
<dd>
FSTRM_RES_FAILURE Permanent failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb33a015a20c5b70966bb45b5afb9923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_free_wrapper </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>free_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for the system's <code>free()</code> function suitable for use as a callback to <a class="el" href="group__fstrm__io.html#gab4287d59ce3a396c5725e55645b1db66" title="Submit a data frame to the background I/O thread. ">fstrm_io_submit()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Object to call <code>free() on</code>. </td></tr>
    <tr><td class="paramname">free_data</td><td>Unused. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab57a03166e6cee802c6a8cce813cc106"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fstrm_io_options* fstrm_io_options_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an <code>fstrm_io_options</code> object, which is needed by <a class="el" href="group__fstrm__io.html#ga8884c56475e2f106859a09302dbb0034" title="Initialize an fstrm_io object. ">fstrm_io_init()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>An <code>fstrm_io_options</code> object which is always non-NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="gaed60ee50b93a0779298e54dfdca40865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_io_options_destroy </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_io_options **&#160;</td>
          <td class="paramname"><em>fopt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an <code>fstrm_io_options</code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fopt</td><td>Pointer to the <code>fstrm_io_options</code> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadf7c89cd378ba39a41218049165af0fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_io_options_set_buffer_hint </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_io_options *&#160;</td>
          <td class="paramname"><em>fopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>buffer_hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <code>buffer_hint</code> option. </p>
<p>This is the threshold number of bytes to accumulate in the output buffer before forcing a buffer flush.</p>
<p>Allowed range: 1024 - 65536 bytes.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__constants.html#ga583c429d7228269efd949ee0d2eab516" title="Default I/O buffer hint size in bytes. ">FSTRM_DEFAULT_IO_BUFFER_HINT</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fopt</td><td><code>fstrm_io_options</code> object. </td></tr>
    <tr><td class="paramname">buffer_hint</td><td>New <code>buffer_hint</code> value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2d59f9ac663390e5f8e362bb9b42c782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_io_options_set_content_type </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_io_options *&#160;</td>
          <td class="paramname"><em>fopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <code>content_type</code> option. </p>
<p>This is a byte string identifying the type of data frames that will be carried over the Frame Streams output and is embedded in a control frame at the start of the Frame Streams output.</p>
<p>The byte string passed in <code>buf</code> will be copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fopt</td><td><code>fstrm_io_options</code> object. </td></tr>
    <tr><td class="paramname">buf</td><td>Byte buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes pointed to by <code>buf</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf4e679938f977674856537ff2efcdc7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_io_options_set_flush_timeout </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_io_options *&#160;</td>
          <td class="paramname"><em>fopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flush_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <code>flush_timeout</code> option. </p>
<p>This is the number of seconds to allow unflushed data to remain in the output queue.</p>
<p>Allowed range: 1 - 600 seconds.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__constants.html#ga010ec42f86cf8b2bf1f68854d06198b6" title="Default I/O flush timeout in seconds. ">FSTRM_DEFAULT_IO_FLUSH_TIMEOUT</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fopt</td><td><code>fstrm_io_options</code> object. </td></tr>
    <tr><td class="paramname">flush_timeout</td><td>New <code>flush_timeout</code> value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaee260467817a459aff1cfcc82ade130e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_io_options_set_iovec_size </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_io_options *&#160;</td>
          <td class="paramname"><em>fopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>iovec_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <code>iovec_size</code> option. </p>
<p>This is the size of the <code>iovec</code> array used to accumulate data in the output queue.</p>
<p>Allowed range: 2 - <code>IOV_MAX</code>. Additionally, <code>iovec_size</code> must be a power of two.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__constants.html#ga1fdfa5ecf3034d5a8eaa08383d1b4696" title="Default size of iovec array. ">FSTRM_DEFAULT_IO_IOVEC_SIZE</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fopt</td><td><code>fstrm_io_options</code> object. </td></tr>
    <tr><td class="paramname">iovec_size</td><td>New <code>iovec_size</code> value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeab932d83d6cdebada2a85c491ffd0dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_io_options_set_num_queues </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_io_options *&#160;</td>
          <td class="paramname"><em>fopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_queues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <code>num_queues</code> option. </p>
<p>This is the number of input queues to create and should match the number of times that <a class="el" href="group__fstrm__io.html#ga5f7dc2ffd79c36977972050fca55c5a1" title="Obtain an fstrm_queue object for submitting data frames to the fstrm_io object. ">fstrm_io_get_queue()</a> is called on the corresponding <code>fstrm_io</code> object.</p>
<p>Allowed range: <code>num_queues</code> must be positive.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__constants.html#gaf0d64e45da5a806c52d9805d536a60b9" title="Default number of I/O queues. ">FSTRM_DEFAULT_IO_NUM_QUEUES</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fopt</td><td><code>fstrm_io_options</code> object. </td></tr>
    <tr><td class="paramname">num_queues</td><td>New <code>num_queues</code> value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga49323ea976e7ed36c47ab488e3300fb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_io_options_set_queue_length </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_io_options *&#160;</td>
          <td class="paramname"><em>fopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>queue_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <code>queue_length</code> option. </p>
<p>This is the number of queue entries to allocate for each input queue. This option controls the number of outstanding data frames that can be enqueued for deferred processing by the I/O thread and thus affects performance and memory usage.</p>
<p>Allowed range: 2 - 16384 queue entries. Additionally, <code>queue_length</code> must be a power of two.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__constants.html#ga4886fe20c13fc1fb229c6ef49ac4a81b" title="Default length of the I/O queue. ">FSTRM_DEFAULT_IO_QUEUE_LENGTH</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fopt</td><td><code>fstrm_io_options</code> object. </td></tr>
    <tr><td class="paramname">queue_length</td><td>New <code>queue_length</code> value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga968bb756b3f5adc0bd0a03fd6e99e4e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_io_options_set_queue_model </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_io_options *&#160;</td>
          <td class="paramname"><em>fopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__constants.html#ga45b55e31b0b151b2990fe86c71a3ca48">fstrm_queue_model</a>&#160;</td>
          <td class="paramname"><em>queue_model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <code>queue_model</code> option. </p>
<p>This controls what queueing semantics to use for <code>fstrm_queue</code> objects. Single Producer queues (<a class="el" href="group__constants.html#gga45b55e31b0b151b2990fe86c71a3ca48a013b7dfa4da6b8dec2d2f5af05292a2a" title="Single Producer, Single Consumer. ">FSTRM_QUEUE_MODEL_SPSC</a>) may only have a single thread at a time calling <a class="el" href="group__fstrm__io.html#gab4287d59ce3a396c5725e55645b1db66" title="Submit a data frame to the background I/O thread. ">fstrm_io_submit()</a> on a given <code>fstrm_queue</code> object, while Multiple Producer queues (<a class="el" href="group__constants.html#gga45b55e31b0b151b2990fe86c71a3ca48af306abdba1e3c30a0da915850cd8d931" title="Multiple Producer, Single Consumer. ">FSTRM_QUEUE_MODEL_MPSC</a>) may have multiple threads simultaneously calling <a class="el" href="group__fstrm__io.html#gab4287d59ce3a396c5725e55645b1db66" title="Submit a data frame to the background I/O thread. ">fstrm_io_submit()</a> on a given <code>fstrm_queue</code> object.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__constants.html#ga45b55e31b0b151b2990fe86c71a3ca48" title="Queue models. ">fstrm_queue_model</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fopt</td><td><code>fstrm_io_options</code> object. </td></tr>
    <tr><td class="paramname">queue_model</td><td>New <code>queue_model</code> value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7a70e58bc3fcd6553d3e5852fbd79be3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_io_options_set_queue_notify_threshold </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_io_options *&#160;</td>
          <td class="paramname"><em>fopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>queue_notify_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <code>queue_notify_threshold</code> option. </p>
<p>This controls the number of outstanding queue entries to allow on an input queue before waking the I/O thread, which will cause the input queue entries to begin draining.</p>
<p>Allowed range: 1 - (<code>queue_length</code> - 1) entries.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__constants.html#ga783ce7b29428d9806d003e161c8b82f1" title="Default number of outstanding queue entries before waking up the I/O thread. ">FSTRM_DEFAULT_IO_QUEUE_NOTIFY_THRESHOLD</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fopt</td><td><code>fstrm_io_options</code> object. </td></tr>
    <tr><td class="paramname">queue_notify_threshold</td><td>New <code>queue_notify_threshold</code> value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad810160c9a4b6f970f0399df533d040d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_io_options_set_reconnect_interval </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_io_options *&#160;</td>
          <td class="paramname"><em>fopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>reconnect_interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <code>reconnect_interval</code> option. </p>
<p>This controls the number of seconds between attempts to reopen a closed output stream.</p>
<p>Allowed range: 1 - 600 seconds.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__constants.html#gac8fb2b0de03441de8a30b96a4de023f3" title="Default interval between I/O reconnection attempts in seconds. ">FSTRM_DEFAULT_IO_RECONNECT_INTERVAL</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fopt</td><td><code>fstrm_io_options</code> object. </td></tr>
    <tr><td class="paramname">reconnect_interval</td><td>New <code>reconnect_interval</code> value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa4c688613ff342028d5e48ed68bd8d13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_io_options_set_writer </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_io_options *&#160;</td>
          <td class="paramname"><em>fopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct fstrm_writer *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>writer_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <code>writer</code> implementation to use for the output stream. </p>
<p>This specifies the concrete implementation that will be used to write Frame Streams data.</p>
<p>Several concrete implementations are provided in the <code>fstrm</code> library. <a class="el" href="group__fstrm__file__writer.html">fstrm_file_writer</a> writes output to a regular file, while <a class="el" href="group__fstrm__unix__writer.html">fstrm_unix_writer</a> writes output to an <code>AF_UNIX</code> socket. To use one of these concrete implementations, for example, <a class="el" href="group__fstrm__unix__writer.html">fstrm_unix_writer</a>, specify <code>fstrm_unix_writer</code> as the <code>writer</code> parameter to <a class="el" href="group__fstrm__io.html#gaa4c688613ff342028d5e48ed68bd8d13" title="Set the writer implementation to use for the output stream. ">fstrm_io_options_set_writer()</a>, and pass an initialized <code>fstrm_unix_writer_options</code> object as the <code>writer_options</code> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fopt</td><td><code>fstrm_io_options</code> object. </td></tr>
    <tr><td class="paramname">writer</td><td><a class="el" href="group__fstrm__writer.html">fstrm_writer</a> object. </td></tr>
    <tr><td class="paramname">writer_options</td><td>An opaque object that is passed to the <code>fstrm_writer</code> implementation. Used for configuring <code>fstrm_writer</code> implementation-specific options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fstrm__writer.html">fstrm_writer</a> </dd>
<dd>
<a class="el" href="group__fstrm__file__writer.html">fstrm_file_writer</a> </dd>
<dd>
<a class="el" href="group__fstrm__unix__writer.html">fstrm_unix_writer</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
