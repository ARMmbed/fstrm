/*
 * Copyright (c) 2014 by Farsight Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * test_writer_hello: simple "hello world" fstrm_io test.
 *
 * Instantiates a dummy writer implementation which captures all writes, then
 * verifies that the correct byte stream sequence was generated by the library.
 */

#include <arpa/inet.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "fstrm.h"

#include "libmy/my_alloc.h"
#include "libmy/print_string.h"

static const char *test_content_type = "test:hello";
static const int num_iterations = 1000;

struct test_buf {
	struct test_buf		*next;
	size_t			len;
	void			*data;
};

static struct test_buf		t_head;
static struct test_buf		*t_cur = &t_head;

static struct test_buf		h_head;
static struct test_buf		*h_cur = &h_head;

static int			num_control_frames = 0;
static int			num_iovecs = 0;

static fstrm_res
fs_test_writer_create(struct fstrm_io *io,
		      const struct fstrm_writer_options *opt,
		      void **data)
{
	fprintf(stderr, "%s: called\n", __func__);
	return FSTRM_RES_SUCCESS;
}

static fstrm_res
fs_test_writer_destroy(void *data)
{
	fprintf(stderr, "%s: called\n", __func__);
	return FSTRM_RES_SUCCESS;
}

static fstrm_res
fs_test_writer_open(void *data)
{
	fprintf(stderr, "%s: called\n", __func__);
	return FSTRM_RES_SUCCESS;
}

static fstrm_res
fs_test_writer_close(void *data)
{
	fprintf(stderr, "%s: called\n", __func__);
	return FSTRM_RES_SUCCESS;
}

static fstrm_res
fs_test_writer_write_control(void *data,
			     struct iovec *iov, int iovcnt,
			     unsigned nbytes)
{
	fprintf(stderr, "%s: called\n", __func__);
	num_control_frames++;

	for (int i = 0; i < iovcnt; i++) {
		fprintf(stderr, "print_string: (%zd) ", iov[i].iov_len);
		print_string(iov[i].iov_base, iov[i].iov_len, stderr);
		fputc('\n', stderr);
	}
	return FSTRM_RES_SUCCESS;
}

static fstrm_res
fs_test_writer_write_data(void *data,
			  struct iovec *iov, int iovcnt,
			  unsigned nbytes)
{
	fprintf(stderr, "%s: called with iovcnt= %d, nbytes= %u\n",
		__func__, iovcnt, nbytes);

	for (int i = 0; i < iovcnt; i++) {
		fprintf(stderr, "write_data: [%d] (%zd) ", i, iov[i].iov_len);
		print_string(iov[i].iov_base, iov[i].iov_len, stderr);
		fputc('\n', stderr);
		t_cur->next = my_calloc(1, sizeof(struct test_buf));
		t_cur = t_cur->next;
		t_cur->len = iov[i].iov_len;
		t_cur->data = my_calloc(1, t_cur->len);
		memmove(t_cur->data, iov[i].iov_base, iov[i].iov_len);
	}
	num_iovecs += iovcnt;
	return FSTRM_RES_SUCCESS;
}

static int
do_checks(void)
{
	struct test_buf *h, *h_next;
	struct test_buf *t, *t_next;

	h = h_head.next;
	t = t_head.next;
	if (!h || !t)
		return EXIT_FAILURE;

	if (num_iovecs != 2*num_iterations) {
		fprintf(stderr, "%s: didn't get the right number of iovec's\n", __func__);
		fprintf(stderr, "%s: num_iovecs= %d, num_iterations= %d\n",
			__func__, num_iovecs, num_iterations);
		return EXIT_FAILURE;
	}

	if (num_control_frames != 2) {
		fprintf(stderr, "%s: didn't get the right number of control frames\n", __func__);
		fprintf(stderr, "%s: num_control_frames = %d\n",
			__func__, num_control_frames);
		return EXIT_FAILURE;
	}

	for (;;) {
		if (!h)
			break;

		assert(h != NULL);
		assert(t != NULL);

		fprintf(stderr, "%s: h->data = (%zd) ", __func__, h->len);
		print_string(h->data, h->len, stderr);
		fputc('\n', stderr);

		fprintf(stderr, "%s: t->data = (%zd) ", __func__, t->len);
		print_string(t->data, t->len, stderr);
		fputc('\n', stderr);

		uint32_t len_wire, len;

		assert(t->len == sizeof(len_wire));
		memmove(&len_wire, t->data, sizeof(len_wire));
		len = ntohl(len_wire);

		assert(t->next != NULL);
		t = t->next;
		fprintf(stderr, "%s: t->data = (%zd) ", __func__, t->len);
		print_string(t->data, t->len, stderr);
		fputc('\n', stderr);

		assert(len == t->len);
		assert(memcmp(h->data, t->data, len) == 0);

		t = t->next;
		h = h->next;
	}


	h = h_head.next;
	for (;;) {
		if (!h)
			break;
		h_next = h->next;
		free(h->data);
		free(h);
		h = h_next;
	}

	t = t_head.next;
	for (;;) {
		if (!t)
			break;
		t_next = t->next;
		free(t->data);
		free(t);
		t = t_next;
	}

	return EXIT_SUCCESS;
}

int
main(void)
{
	char *err = NULL;
	struct fstrm_io *io = NULL;
	struct fstrm_io_options *io_opt = NULL;
	struct fstrm_queue *fq = NULL;
	struct fstrm_writer *w = NULL;

	w = fstrm_writer_init();

	fstrm_writer_set_create(w, fs_test_writer_create);
	fstrm_writer_set_destroy(w, fs_test_writer_destroy);
	fstrm_writer_set_open(w, fs_test_writer_open);
	fstrm_writer_set_close(w, fs_test_writer_close);
	fstrm_writer_set_write_control(w, fs_test_writer_write_control);
	fstrm_writer_set_write_data(w, fs_test_writer_write_data);

	io_opt = fstrm_io_options_init();
	fstrm_io_options_set_writer(io_opt, w, NULL);
	fstrm_io_options_set_content_type(io_opt,
					  test_content_type,
					  strlen(test_content_type));

	io = fstrm_io_init(io_opt, &err);
	if (io == NULL) {
		fprintf(stderr, "fstrm_io_init() failed: %s\n", err);
		return EXIT_FAILURE;
	}

	fstrm_io_options_destroy(&io_opt);
	fstrm_writer_destroy(&w);

	fq = fstrm_io_get_queue(io);
	if (fq == NULL) {
		fprintf(stderr, "fstrm_io_get_queue() failed\n");
		return EXIT_FAILURE;
	}

	for (int i = 0; i < num_iterations; i++) {
		char buf[100];
		char *bytes;

		buf[0] = '\0';
		sprintf(buf, "hello world #%d", i);

		h_cur->next = my_calloc(1, sizeof(*h_cur->next));
		h_cur = h_cur->next;
		h_cur->len = strlen(buf);
		h_cur->data = my_strdup(buf);

		bytes = my_strdup(buf);

		for (;;) {
			fstrm_res res;

			res = fstrm_io_submit(io, fq, bytes, strlen(bytes),
					      fstrm_free_wrapper, NULL);
			if (res == FSTRM_RES_SUCCESS) {
				break;
			} else if (res == FSTRM_RES_AGAIN) {
				poll(NULL, 0, 1); /* sleep for a millisecond */
				continue;
			} else {
				free(bytes);
				fprintf(stderr, "fstrm_io_submit() failed\n");
				return EXIT_FAILURE;
			}
		}
	}

	fstrm_io_destroy(&io);

	return do_checks();
}
