<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>fstrm: fstrm_control</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fstrm
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">Frame Streams implementation in C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__fstrm__control.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fstrm_control</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><code>fstrm_control</code> is an interface for encoding and decoding Frame Streams control frames. </p>
<p>Two types of frames are possible in a Frame Streams byte stream: <b>data frames</b> and <b>control frames</b>. Both are variable length byte sequences prefixed by a 32-bit big endian unsigned integer (the <b>frame length</b>) specifying the length of the following byte sequence. If this frame length value is greater than zero, the <b>frame length</b> specifies the <b>data frame length</b>, and a data frame follows it. If the frame length is zero (i.e., it is the four byte sequence <code>00 00 00 00</code>), this is an <b>escape sequence</b>, which means that a control frame follows. The control frame itself is prefixed by a 32-bit big endian unsigned integer (the <b>control frame length</b>) specifying the length of the following <b>control frame payload</b>.</p>
<p>There are two types of control frames used for uni-directional streams: <code>START</code> and <code>STOP</code>. These control frame types bracket the stream of data frames. <code>START</code> indicates the beginning of the stream and communicates metadata about the stream to follow, and <code>STOP</code> indicates the end of the stream.</p>
<p>Bi-directional streams make use of three additional control frame types: <code>READY</code>, <code>ACCEPT</code>, and <code>FINISH</code>. These control frame types are used in a simple handshake protocol between sender and receiver.</p>
<p>A uni-directional Frame Streams byte stream normally consists of the following:</p>
<ol type="1">
<li>The <code>START</code> control frame.</li>
<li>A sequence of zero or more data frames or control frames that are not of the control frame types <code>START</code>, <code>STOP</code>, <code>ACCEPT</code>, <code>READY</code>, or <code>FINISH</code>.</li>
<li>The <code>STOP</code> control frame.</li>
</ol>
<p>The <code>START</code> and <code>STOP</code> control frames are not optional. The <code>START</code> control frame must appear at the beginning of the byte stream, and the <code>STOP</code> control frame must appear at the end of the byte stream. (If the byte stream has an end.) <code>START</code> control frames must not appear anywhere other than at the beginning of the byte stream, and <code>STOP</code> control frames must not appear anywhere other than at the end of the byte stream. Only one <code>START</code> control frame and only one <code>STOP</code> control frame may appear in a Frame Streams byte stream.</p>
<p>Control frames may optionally include zero or more <b>control frame fields</b>. There is currently one type of control frame field defined: <code>CONTENT_TYPE</code>. This field specifies a variable length byte sequence describing the encoding of data frames that appear in the Frame Streams byte stream. This field is used by cooperating programs to unambiguously identify how to interpret the data frames in a particular Frame Streams byte stream. For instance, this field may specify a particular schema to use to interpret the data frames appearing in the byte stream. Zero, one, or more <code>CONTENT_TYPE</code> fields may appear in <code>READY</code> or <code>ACCEPT</code> control frames. Zero or one <code>CONTENT_TYPE</code> fields may appear in <code>START</code> control frames. No <code>CONTENT_TYPE</code> fields may appear in <code>STOP</code> or <code>FINISH</code> control frames.</p>
<p>A uni-directional Frame Streams encoder would normally produce a byte stream as follows:</p>
<ol type="1">
<li>Write the <code>START</code> <b>control frame</b>.<ul>
<li>At the start of the byte stream, write the four byte <b>escape sequence</b> <code>00 00 00 00</code> that precedes control frames.</li>
<li>Write the <b>control frame length</b> as a 32-bit big endian unsigned integer.</li>
<li>Write the <b>control frame payload</b>. It must be a <code>START</code> control frame. It may optionally specify a <code>CONTENT_TYPE</code> field.</li>
</ul>
</li>
<li>Write zero or more <b>data frames</b>.</li>
<li>Write the <code>STOP</code> <b>control frame</b>.<ul>
<li>At the start of the byte stream, write the four byte <b>escape sequence</b> <code>00 00 00 00</code> that precedes control frames.</li>
<li>Write the <b>control frame length</b> as a 32-bit big endian unsigned integer.</li>
<li>Write the <b>control frame payload</b>. It must be a <code>STOP</code> control frame.</li>
</ul>
</li>
</ol>
<p>A uni-directional Frame Streams decoder would normally process the byte stream as follows:</p>
<ol type="1">
<li>Read the <code>START</code> control frame.<ul>
<li>At the start of the byte stream, read the four byte <b>escape sequence</b> <code>00 00 00 00</code> that precedes control frames.</li>
<li>Read the 32-bit big endian unsigned integer specifying the <b>control frame length</b>.</li>
<li>Decode the <b>control frame payload</b>. It must be a <code>START</code> control frame. It may optionally specify a <code>CONTENT_TYPE</code> field.</li>
</ul>
</li>
<li>Repeatedly read data frames or control frames following the <code>START</code> control frame.<ul>
<li>Read the <b>frame length</b>, a 32-bit big endian unsigned integer.</li>
<li>If the <b>frame length</b> is zero, a control frame follows:<ul>
<li>Read the 32-bit big endian unsigned integer specifying the <b>control frame length</b>.</li>
<li>Decode the <b>control frame payload</b>. If it is a <code>STOP</code> control frame, the end of the Frame Streams byte stream has occurred, and no frames follow. Break out of the decoding loop and halt processing. (<code>READY</code>, <code>ACCEPT</code>, <code>START</code>, and <code>FINISH</code> may not occur here. For forward compatibility, control frames of types other than the types <code>READY</code>, <code>ACCEPT</code>, <code>START</code>, <code>STOP</code>, and <code>FINISH</code> must be ignored here. No control frames specified in the future may alter the encoding of succeeding frames.)</li>
</ul>
</li>
<li>If the <b>frame length</b> is non-zero, it specifies the number of bytes in the following <b>data frame</b>. Consume these bytes from the byte stream.</li>
</ul>
</li>
</ol>
<p>The functions <a class="el" href="group__fstrm__control.html#ga4ae9c09cb17525cdf4cec4a17ce3017f" title="Encode a control frame into a buffer. ">fstrm_control_encode()</a> and <a class="el" href="group__fstrm__control.html#gaa5328a17b32c72d97050342d1e02353c" title="Decode a control frame from a buffer. ">fstrm_control_decode()</a> are provided to encode and decode control frames. See the detailed descriptions of those functions for code examples showing their usage. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4e67dcc80e7190fef15b35f85c596e8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#ga4e67dcc80e7190fef15b35f85c596e8d">FSTRM_CONTROL_FRAME_LENGTH_MAX</a>&#160;&#160;&#160;512</td></tr>
<tr class="memdesc:ga4e67dcc80e7190fef15b35f85c596e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length in bytes of an "Accept", "Start", or "Stop" control frame payload.  <a href="#ga4e67dcc80e7190fef15b35f85c596e8d">More...</a><br /></td></tr>
<tr class="separator:ga4e67dcc80e7190fef15b35f85c596e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a7fbb8f7f9e3354f314886f8119e13c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#ga2a7fbb8f7f9e3354f314886f8119e13c">FSTRM_CONTROL_FIELD_CONTENT_TYPE_LENGTH_MAX</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:ga2a7fbb8f7f9e3354f314886f8119e13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length in bytes of a "Content Type" control frame field payload.  <a href="#ga2a7fbb8f7f9e3354f314886f8119e13c">More...</a><br /></td></tr>
<tr class="separator:ga2a7fbb8f7f9e3354f314886f8119e13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga0210744b7c387b0ae6d55e9737c40117"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#ga0210744b7c387b0ae6d55e9737c40117">fstrm_control_type</a> </td></tr>
<tr class="memdesc:ga0210744b7c387b0ae6d55e9737c40117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control frame types.  <a href="group__fstrm__control.html#ga0210744b7c387b0ae6d55e9737c40117">More...</a><br /></td></tr>
<tr class="separator:ga0210744b7c387b0ae6d55e9737c40117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81def568690686c13dff680b1b0c4d25"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#ga81def568690686c13dff680b1b0c4d25">fstrm_control_field</a> </td></tr>
<tr class="memdesc:ga81def568690686c13dff680b1b0c4d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control frame field types.  <a href="group__fstrm__control.html#ga81def568690686c13dff680b1b0c4d25">More...</a><br /></td></tr>
<tr class="separator:ga81def568690686c13dff680b1b0c4d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeea197ecccbc24933fecb30aa90826d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#gabeea197ecccbc24933fecb30aa90826d">fstrm_control_flag</a> </td></tr>
<tr class="memdesc:gabeea197ecccbc24933fecb30aa90826d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags for controlling the behavior of the encoding and decoding functions.  <a href="group__fstrm__control.html#gabeea197ecccbc24933fecb30aa90826d">More...</a><br /></td></tr>
<tr class="separator:gabeea197ecccbc24933fecb30aa90826d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6cb915068a99803f322231f52fdad8d5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#ga6cb915068a99803f322231f52fdad8d5">fstrm_control_type_to_str</a> (<a class="el" href="group__fstrm__control.html#ga0210744b7c387b0ae6d55e9737c40117">fstrm_control_type</a> type)</td></tr>
<tr class="memdesc:ga6cb915068a99803f322231f52fdad8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <code>fstrm_control_type</code> enum value to a string representation.  <a href="#ga6cb915068a99803f322231f52fdad8d5">More...</a><br /></td></tr>
<tr class="separator:ga6cb915068a99803f322231f52fdad8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79019ca8c7dbb743fcc5a769f6167d7d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#ga79019ca8c7dbb743fcc5a769f6167d7d">fstrm_control_field_type_to_str</a> (<a class="el" href="group__fstrm__control.html#ga81def568690686c13dff680b1b0c4d25">fstrm_control_field</a> f_type)</td></tr>
<tr class="memdesc:ga79019ca8c7dbb743fcc5a769f6167d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <code>fstrm_control_field</code> enum value to a string representation.  <a href="#ga79019ca8c7dbb743fcc5a769f6167d7d">More...</a><br /></td></tr>
<tr class="separator:ga79019ca8c7dbb743fcc5a769f6167d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32839f6d4dd5e9c5554c9d6cbd4e69e1"><td class="memItemLeft" align="right" valign="top">struct fstrm_control *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#ga32839f6d4dd5e9c5554c9d6cbd4e69e1">fstrm_control_init</a> (void)</td></tr>
<tr class="memdesc:ga32839f6d4dd5e9c5554c9d6cbd4e69e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <code>fstrm_control</code> object.  <a href="#ga32839f6d4dd5e9c5554c9d6cbd4e69e1">More...</a><br /></td></tr>
<tr class="separator:ga32839f6d4dd5e9c5554c9d6cbd4e69e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dbe51deff01060740ff09402410d1e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#ga5dbe51deff01060740ff09402410d1e2">fstrm_control_destroy</a> (struct fstrm_control **c)</td></tr>
<tr class="memdesc:ga5dbe51deff01060740ff09402410d1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an <code>fstrm_control</code> object.  <a href="#ga5dbe51deff01060740ff09402410d1e2">More...</a><br /></td></tr>
<tr class="separator:ga5dbe51deff01060740ff09402410d1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ff26d2c5eb6d2aad9a8c303547be23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#ga29ff26d2c5eb6d2aad9a8c303547be23">fstrm_control_reset</a> (struct fstrm_control *c)</td></tr>
<tr class="memdesc:ga29ff26d2c5eb6d2aad9a8c303547be23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize an <code>fstrm_control</code> object.  <a href="#ga29ff26d2c5eb6d2aad9a8c303547be23">More...</a><br /></td></tr>
<tr class="separator:ga29ff26d2c5eb6d2aad9a8c303547be23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce9edd88f281429f8417a1c686ee1a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#gabce9edd88f281429f8417a1c686ee1a5">fstrm_control_get_type</a> (const struct fstrm_control *c, <a class="el" href="group__fstrm__control.html#ga0210744b7c387b0ae6d55e9737c40117">fstrm_control_type</a> *type)</td></tr>
<tr class="memdesc:gabce9edd88f281429f8417a1c686ee1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the type of the control frame.  <a href="#gabce9edd88f281429f8417a1c686ee1a5">More...</a><br /></td></tr>
<tr class="separator:gabce9edd88f281429f8417a1c686ee1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b7a7454dee3e122c1f2ac55720cddc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#ga5b7a7454dee3e122c1f2ac55720cddc2">fstrm_control_set_type</a> (struct fstrm_control *c, <a class="el" href="group__fstrm__control.html#ga0210744b7c387b0ae6d55e9737c40117">fstrm_control_type</a> type)</td></tr>
<tr class="memdesc:ga5b7a7454dee3e122c1f2ac55720cddc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the type of the control frame.  <a href="#ga5b7a7454dee3e122c1f2ac55720cddc2">More...</a><br /></td></tr>
<tr class="separator:ga5b7a7454dee3e122c1f2ac55720cddc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7656071d8c5168a367306b831fd43b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#gac7656071d8c5168a367306b831fd43b9">fstrm_control_get_num_field_content_type</a> (const struct fstrm_control *c, size_t *n_content_type)</td></tr>
<tr class="memdesc:gac7656071d8c5168a367306b831fd43b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of "Content Type" fields present in the control frame.  <a href="#gac7656071d8c5168a367306b831fd43b9">More...</a><br /></td></tr>
<tr class="separator:gac7656071d8c5168a367306b831fd43b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c08659f162b1927cbaacc3a529439e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#ga8c08659f162b1927cbaacc3a529439e8">fstrm_control_get_field_content_type</a> (const struct fstrm_control *c, const size_t idx, const uint8_t **content_type, size_t *len_content_type)</td></tr>
<tr class="memdesc:ga8c08659f162b1927cbaacc3a529439e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a "Content Type" field from the control frame.  <a href="#ga8c08659f162b1927cbaacc3a529439e8">More...</a><br /></td></tr>
<tr class="separator:ga8c08659f162b1927cbaacc3a529439e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab6a5aed259882afc8d8e3dd60294ec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#gaab6a5aed259882afc8d8e3dd60294ec9">fstrm_control_add_field_content_type</a> (struct fstrm_control *c, const uint8_t *content_type, size_t len_content_type)</td></tr>
<tr class="memdesc:gaab6a5aed259882afc8d8e3dd60294ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a "Content Type" field to the control frame.  <a href="#gaab6a5aed259882afc8d8e3dd60294ec9">More...</a><br /></td></tr>
<tr class="separator:gaab6a5aed259882afc8d8e3dd60294ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48944bf9595da151055fecdd0b510aae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#ga48944bf9595da151055fecdd0b510aae">fstrm_control_match_field_content_type</a> (const struct fstrm_control *c, const uint8_t *match, const size_t len_match)</td></tr>
<tr class="memdesc:ga48944bf9595da151055fecdd0b510aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the control frame matches a particular content type value.  <a href="#ga48944bf9595da151055fecdd0b510aae">More...</a><br /></td></tr>
<tr class="separator:ga48944bf9595da151055fecdd0b510aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5328a17b32c72d97050342d1e02353c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#gaa5328a17b32c72d97050342d1e02353c">fstrm_control_decode</a> (struct fstrm_control *c, const void *control_frame, size_t len_control_frame, const uint32_t flags)</td></tr>
<tr class="memdesc:gaa5328a17b32c72d97050342d1e02353c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a control frame from a buffer.  <a href="#gaa5328a17b32c72d97050342d1e02353c">More...</a><br /></td></tr>
<tr class="separator:gaa5328a17b32c72d97050342d1e02353c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1049654e60649d4f02db11026173399e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#ga1049654e60649d4f02db11026173399e">fstrm_control_encoded_size</a> (const struct fstrm_control *c, size_t *len_control_frame, const uint32_t flags)</td></tr>
<tr class="memdesc:ga1049654e60649d4f02db11026173399e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the number of bytes needed to serialize the control frame.  <a href="#ga1049654e60649d4f02db11026173399e">More...</a><br /></td></tr>
<tr class="separator:ga1049654e60649d4f02db11026173399e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae9c09cb17525cdf4cec4a17ce3017f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstrm__control.html#ga4ae9c09cb17525cdf4cec4a17ce3017f">fstrm_control_encode</a> (const struct fstrm_control *c, void *control_frame, size_t *len_control_frame, const uint32_t flags)</td></tr>
<tr class="memdesc:ga4ae9c09cb17525cdf4cec4a17ce3017f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a control frame into a buffer.  <a href="#ga4ae9c09cb17525cdf4cec4a17ce3017f">More...</a><br /></td></tr>
<tr class="separator:ga4ae9c09cb17525cdf4cec4a17ce3017f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga4e67dcc80e7190fef15b35f85c596e8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSTRM_CONTROL_FRAME_LENGTH_MAX&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum length in bytes of an "Accept", "Start", or "Stop" control frame payload. </p>
<p>This excludes the escape sequence and the control frame length. </p>

</div>
</div>
<a class="anchor" id="ga2a7fbb8f7f9e3354f314886f8119e13c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSTRM_CONTROL_FIELD_CONTENT_TYPE_LENGTH_MAX&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum length in bytes of a "Content Type" control frame field payload. </p>
<p>This excludes the field type and payload length. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga0210744b7c387b0ae6d55e9737c40117"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fstrm__control.html#ga0210744b7c387b0ae6d55e9737c40117">fstrm_control_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control frame types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga0210744b7c387b0ae6d55e9737c40117aacb88c15de46b675fe709462fa1f1065"></a>FSTRM_CONTROL_ACCEPT&#160;</td><td class="fielddoc">
<p>Control frame type value for "Accept" control frames. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0210744b7c387b0ae6d55e9737c40117a3c99a233e0c4c15cd815c430bcdfe8a6"></a>FSTRM_CONTROL_START&#160;</td><td class="fielddoc">
<p>Control frame type value for "Start" control frames. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0210744b7c387b0ae6d55e9737c40117a4c3d9549d3f2b1e9698812c2200a77bf"></a>FSTRM_CONTROL_STOP&#160;</td><td class="fielddoc">
<p>Control frame type value for "Stop" control frames. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0210744b7c387b0ae6d55e9737c40117a5a1f42c2241109e82c0c7ae514e3716f"></a>FSTRM_CONTROL_READY&#160;</td><td class="fielddoc">
<p>Control frame type value for "Ready" control frames. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0210744b7c387b0ae6d55e9737c40117a85cc8b3a38b90d651d882c46307ae140"></a>FSTRM_CONTROL_FINISH&#160;</td><td class="fielddoc">
<p>Control frame type value for "Finish" control frames. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga81def568690686c13dff680b1b0c4d25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fstrm__control.html#ga81def568690686c13dff680b1b0c4d25">fstrm_control_field</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control frame field types. </p>
<p>These are optional fields that can appear in control frames. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga81def568690686c13dff680b1b0c4d25a990a2704f3e6070055c387085244b47d"></a>FSTRM_CONTROL_FIELD_CONTENT_TYPE&#160;</td><td class="fielddoc">
<p>Control frame field type value for the "Content Type" control frame option. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gabeea197ecccbc24933fecb30aa90826d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fstrm__control.html#gabeea197ecccbc24933fecb30aa90826d">fstrm_control_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for controlling the behavior of the encoding and decoding functions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggabeea197ecccbc24933fecb30aa90826da32b9304249abae50dd127091b0d7ae19"></a>FSTRM_CONTROL_FLAG_WITH_HEADER&#160;</td><td class="fielddoc">
<p>Set to control whether to include the control frame header in encoding/decoding operations. </p>
<p>Causes <a class="el" href="group__fstrm__control.html#ga4ae9c09cb17525cdf4cec4a17ce3017f" title="Encode a control frame into a buffer. ">fstrm_control_encode()</a> and <a class="el" href="group__fstrm__control.html#ga1049654e60649d4f02db11026173399e" title="Calculate the number of bytes needed to serialize the control frame. ">fstrm_control_encoded_size()</a> to include the control frame header containing the escape sequence and control frame payload length in the encoded output. Otherwise, only the control frame payload itself is encoded.</p>
<p>Tells <a class="el" href="group__fstrm__control.html#gaa5328a17b32c72d97050342d1e02353c" title="Decode a control frame from a buffer. ">fstrm_control_decode()</a> that the input buffer to be decoded begins with the control frame header containing the escape sequence and control frame payload length. (Note that this requires the caller to peek at the input buffer to calculate the right buffer length.) Otherwise, the input buffer begins with the control frame payload. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6cb915068a99803f322231f52fdad8d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* fstrm_control_type_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fstrm__control.html#ga0210744b7c387b0ae6d55e9737c40117">fstrm_control_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <code>fstrm_control_type</code> enum value to a string representation. </p>
<p>Unknown values are represented as <code>"FSTRM_CONTROL_UNKNOWN"</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The <code>fstrm_control_type</code> enum value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the enum value. (Always non-NULL.) </dd></dl>

</div>
</div>
<a class="anchor" id="ga79019ca8c7dbb743fcc5a769f6167d7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* fstrm_control_field_type_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fstrm__control.html#ga81def568690686c13dff680b1b0c4d25">fstrm_control_field</a>&#160;</td>
          <td class="paramname"><em>f_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <code>fstrm_control_field</code> enum value to a string representation. </p>
<p>Unknown values are represented as <code>"FSTRM_CONTROL_FIELD_UNKNOWN"</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f_type</td><td>The <code>fstrm_control_field</code> enum value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the enum value. (Always non-NULL.) </dd></dl>

</div>
</div>
<a class="anchor" id="ga32839f6d4dd5e9c5554c9d6cbd4e69e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fstrm_control* fstrm_control_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an <code>fstrm_control</code> object. </p>
<p>This object represents Frame Streams control frames and is used for encoding and decoding control frames.</p>
<dl class="section return"><dt>Returns</dt><dd>An <code>fstrm_control</code> object. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5dbe51deff01060740ff09402410d1e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_control_destroy </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_control **&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an <code>fstrm_control</code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Pointer to an <code>fstrm_control</code> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga29ff26d2c5eb6d2aad9a8c303547be23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fstrm_control_reset </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_control *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinitialize an <code>fstrm_control</code> object. </p>
<p>This resets the internal state to default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td><code>fstrm_control</code> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabce9edd88f281429f8417a1c686ee1a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a> fstrm_control_get_type </td>
          <td>(</td>
          <td class="paramtype">const struct fstrm_control *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fstrm__control.html#ga0210744b7c387b0ae6d55e9737c40117">fstrm_control_type</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the type of the control frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">c</td><td><code>fstrm_control</code> object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>Type of the control frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329a89de17ab416590c6c61b2b5f7dd7844a" title="Success. ">fstrm_res_success</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329ab519f1b47be22d4f1b3ebe799a1c805b" title="Failure. ">fstrm_res_failure</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5b7a7454dee3e122c1f2ac55720cddc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a> fstrm_control_set_type </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_control *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fstrm__control.html#ga0210744b7c387b0ae6d55e9737c40117">fstrm_control_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the type of the control frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">c</td><td><code>fstrm_control</code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of the control frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329a89de17ab416590c6c61b2b5f7dd7844a" title="Success. ">fstrm_res_success</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329ab519f1b47be22d4f1b3ebe799a1c805b" title="Failure. ">fstrm_res_failure</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac7656071d8c5168a367306b831fd43b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a> fstrm_control_get_num_field_content_type </td>
          <td>(</td>
          <td class="paramtype">const struct fstrm_control *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>n_content_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of "Content Type" fields present in the control frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">c</td><td><code>fstrm_control</code> object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n_content_type</td><td>The number of "Content Type" fields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329a89de17ab416590c6c61b2b5f7dd7844a" title="Success. ">fstrm_res_success</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329ab519f1b47be22d4f1b3ebe799a1c805b" title="Failure. ">fstrm_res_failure</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c08659f162b1927cbaacc3a529439e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a> fstrm_control_get_field_content_type </td>
          <td>(</td>
          <td class="paramtype">const struct fstrm_control *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t **&#160;</td>
          <td class="paramname"><em>content_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len_content_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a "Content Type" field from the control frame. </p>
<p>This function returns a reference which must not be modified. Control frames may contain zero, one, or more "Content Type" fields.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__fstrm__control.html#gac7656071d8c5168a367306b831fd43b9" title="Retrieve the number of &quot;Content Type&quot; fields present in the control frame. ">fstrm_control_get_num_field_content_type()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">c</td><td><code>fstrm_control</code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The index of the "Content Type" field to retrieve. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">content_type</td><td>Pointer to where the reference to the "Content Type" string will be stored. Note that this string is not NUL-terminated and may contain embedded NULs. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">len_content_type</td><td>The number of bytes in <code>content_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329a89de17ab416590c6c61b2b5f7dd7844a" title="Success. ">fstrm_res_success</a></td><td>The control frame has a "Content Type" field. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329ab519f1b47be22d4f1b3ebe799a1c805b" title="Failure. ">fstrm_res_failure</a></td><td>The control frame does not have a "Content Type" field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab6a5aed259882afc8d8e3dd60294ec9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a> fstrm_control_add_field_content_type </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_control *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>content_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_content_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a "Content Type" field to the control frame. </p>
<p>This function makes a copy of the provided string. This function may be called multiple times, in which case multiple "Content Type" fields will be added to the control frame.</p>
<p>The "Content Type" fields are removed on a call to <a class="el" href="group__fstrm__control.html#ga29ff26d2c5eb6d2aad9a8c303547be23" title="Reinitialize an fstrm_control object. ">fstrm_control_reset()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">c</td><td><code>fstrm_control</code> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">content_type</td><td>The "Content Type" string to copy. Note that this string is not NUL-terminated and may contain embedded NULs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len_content_type</td><td>The number of bytes in <code>content_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329a89de17ab416590c6c61b2b5f7dd7844a" title="Success. ">fstrm_res_success</a></td><td>The "Content Type" field was successfully added. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329ab519f1b47be22d4f1b3ebe799a1c805b" title="Failure. ">fstrm_res_failure</a></td><td>The "Content Type" string is too long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga48944bf9595da151055fecdd0b510aae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a> fstrm_control_match_field_content_type </td>
          <td>(</td>
          <td class="paramtype">const struct fstrm_control *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>len_match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the control frame matches a particular content type value. </p>
<p>That is, the content type given in the <code>match</code> and <code>len_match</code> parameters is checked for compatibility with the content types (if any) specified in the control frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td><code>fstrm_control</code> object. </td></tr>
    <tr><td class="paramname">match</td><td>The "Content Type" string to match. Note that this string is not NUL-terminated and may contain embedded NULs. May be NULL, in which case the control frame must not have any content type fields in order to match. </td></tr>
    <tr><td class="paramname">len_match</td><td>The number of bytes in <code>match</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329a89de17ab416590c6c61b2b5f7dd7844a" title="Success. ">fstrm_res_success</a></td><td>A match was found. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329ab519f1b47be22d4f1b3ebe799a1c805b" title="Failure. ">fstrm_res_failure</a></td><td>A match was not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa5328a17b32c72d97050342d1e02353c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a> fstrm_control_decode </td>
          <td>(</td>
          <td class="paramtype">struct fstrm_control *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>control_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_control_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a control frame from a buffer. </p>
<p>The buffer starts with either the escape sequence or the control frame payload depending on whether the <code>FSTRM_CONTROL_FLAG_WITH_HEADER</code> flag is set or not. In either case, the 'len_control_frame' parameter must be exact. Underflow or overflow is not permitted.</p>
<p>The following code example shows a function that decodes a control frame payload: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;static fstrm_res</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;decode_control_frame(const void *control_frame, size_t len_control_frame)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        fstrm_res res;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        fstrm_control_type c_type;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        struct fstrm_control *c;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        uint32_t flags = 0;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        c = fstrm_control_init();</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        res = fstrm_control_decode(c, control_frame, len_control_frame, flags);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;        if (res != fstrm_res_success) {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;                puts(&quot;fstrm_control_decode() failed.&quot;);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;                fstrm_control_destroy(&amp;c);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;                return res;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        }</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        res = fstrm_control_get_type(c, &amp;c_type);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        if (res != fstrm_res_success) {</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;                puts(&quot;fstrm_control_get_type() failed.&quot;);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;                fstrm_control_destroy(&amp;c);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;                return res;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        }</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;        printf(&quot;The control frame is of type %s (%u).\n&quot;,</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;               fstrm_control_type_to_str(c_type), c_type);</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        size_t n_content_type;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;        res = fstrm_control_get_num_field_content_type(c, &amp;n_content_type);</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        if (res != fstrm_res_success) {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                puts(&quot;fstrm_control_get_num_field_content_type() failed.&quot;);</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                fstrm_control_destroy(&amp;c);</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                return res;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        }</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        const uint8_t *content_type;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        size_t len_content_type;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        for (size_t idx = 0; idx &lt; n_content_type; idx++) {</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;                res = fstrm_control_get_field_content_type(c, idx,</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                        &amp;content_type, &amp;len_content_type);</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;                if (res == fstrm_res_success) {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;                        printf(&quot;The control frame has a CONTENT_TYPE field of length %zd.\n&quot;,</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                               len_content_type);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                }</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        }</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        fstrm_control_destroy(&amp;c);</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        return fstrm_res_success;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">c</td><td><code>fstrm_control</code> object. Its state will be overwritten. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">control_frame</td><td>Buffer containing the serialized control frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len_control_frame</td><td>The number of bytes in <code>control_frame</code>. This parameter must specify the exact number of bytes in the control frame. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>Flags controlling the decoding process. See <a class="el" href="group__fstrm__control.html#gabeea197ecccbc24933fecb30aa90826d" title="Flags for controlling the behavior of the encoding and decoding functions. ">fstrm_control_flag</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329a89de17ab416590c6c61b2b5f7dd7844a" title="Success. ">fstrm_res_success</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329ab519f1b47be22d4f1b3ebe799a1c805b" title="Failure. ">fstrm_res_failure</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1049654e60649d4f02db11026173399e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a> fstrm_control_encoded_size </td>
          <td>(</td>
          <td class="paramtype">const struct fstrm_control *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len_control_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the number of bytes needed to serialize the control frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">c</td><td><code>fstrm_control</code> object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">len_control_frame</td><td>The number of bytes needed to encode <code>c</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>Flags controlling the encoding process. See <a class="el" href="group__fstrm__control.html#gabeea197ecccbc24933fecb30aa90826d" title="Flags for controlling the behavior of the encoding and decoding functions. ">fstrm_control_flag</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329a89de17ab416590c6c61b2b5f7dd7844a" title="Success. ">fstrm_res_success</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329ab519f1b47be22d4f1b3ebe799a1c805b" title="Failure. ">fstrm_res_failure</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4ae9c09cb17525cdf4cec4a17ce3017f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329">fstrm_res</a> fstrm_control_encode </td>
          <td>(</td>
          <td class="paramtype">const struct fstrm_control *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>control_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len_control_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a control frame into a buffer. </p>
<p>Since a Frame Streams control frame is a variable length byte sequence of up to <a class="el" href="group__fstrm__control.html#ga4e67dcc80e7190fef15b35f85c596e8d" title="The maximum length in bytes of an &quot;Accept&quot;, &quot;Start&quot;, or &quot;Stop&quot; control frame payload. ">FSTRM_CONTROL_FRAME_LENGTH_MAX</a> bytes, this function can be used in two different ways. The first way is to call <a class="el" href="group__fstrm__control.html#ga1049654e60649d4f02db11026173399e" title="Calculate the number of bytes needed to serialize the control frame. ">fstrm_control_encoded_size()</a> to obtain the exact number of bytes needed to encode the frame, and then pass a buffer of this exact size to <a class="el" href="group__fstrm__control.html#ga4ae9c09cb17525cdf4cec4a17ce3017f" title="Encode a control frame into a buffer. ">fstrm_control_encode()</a>. The following example shows this usage: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;fstrm_res res;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;struct fstrm_control *c;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;uint8_t *control_frame;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;size_t len_control_frame;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;uint32_t flags = 0;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;c = fstrm_control_init();</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;res = fstrm_control_set_type(c, FSTRM_CONTROL_START);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;if (res != fstrm_res_success) {</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        // Error handling goes here.</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;// Calculate the number of bytes needed.</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;res = fstrm_control_encoded_size(c, &amp;len_control_frame, flags);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;if (res != fstrm_res_success) {</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        // Error handling goes here.</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;}</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;// &#39;len_control_frame&#39; now specifies the number of bytes required for</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;// the control frame. Allocate the needed space.</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;control_frame = malloc(len_control_frame);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;if (!control_frame) {</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        // Error handling goes here.</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;}</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;// Serialize the control frame into the allocated buffer.</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;res = fstrm_control_encode(c, control_frame, &amp;len_control_frame, 0);</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;if (res != fstrm_res_success) {</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        // Error handling goes here.</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;}</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;// Do something with &#39;control_frame&#39; and &#39;len_control_frame&#39;.</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;// Clean up.</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;free(control_frame);</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;fstrm_control_destroy(&amp;c);</div>
</div><!-- fragment --><p>The second way to use <a class="el" href="group__fstrm__control.html#ga4ae9c09cb17525cdf4cec4a17ce3017f" title="Encode a control frame into a buffer. ">fstrm_control_encode()</a> is to allocate a statically sized buffer of <a class="el" href="group__fstrm__control.html#ga4e67dcc80e7190fef15b35f85c596e8d" title="The maximum length in bytes of an &quot;Accept&quot;, &quot;Start&quot;, or &quot;Stop&quot; control frame payload. ">FSTRM_CONTROL_FRAME_LENGTH_MAX</a> bytes. The exact number of bytes serialized by the encoder will be returned in the <code>len_control_frame</code> parameter. The following example shows this usage: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;fstrm_res res;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;struct fstrm_control *c;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;uint8_t control_frame[FSTRM_CONTROL_FRAME_LENGTH_MAX];</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;size_t len_control_frame = sizeof(control_frame);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;c = fstrm_control_init();</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;res = fstrm_control_set_type(c, FSTRM_CONTROL_START);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;if (res != fstrm_res_success) {</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        // Error handling.</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;// Serialize the control frame.</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;res = fstrm_control_encode(c, control_frame, &amp;len_control_frame, 0);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;if (res != fstrm_res_success) {</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        // Error handling goes here.</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;}</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;// Do something with &#39;control_frame&#39; and &#39;len_control_frame&#39;.</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;// Clean up.</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;fstrm_control_destroy(&amp;c);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">c</td><td><code>fstrm_control</code> object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">control_frame</td><td>The buffer in which to serialize the control frame. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len_control_frame</td><td>The size in bytes of <code>control_frame</code>. On a successful return, contains the number of bytes actually written into <code>control_frame</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>Flags controlling the encoding process. See <a class="el" href="group__fstrm__control.html#gabeea197ecccbc24933fecb30aa90826d" title="Flags for controlling the behavior of the encoding and decoding functions. ">fstrm_control_flag</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329a89de17ab416590c6c61b2b5f7dd7844a" title="Success. ">fstrm_res_success</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329ab519f1b47be22d4f1b3ebe799a1c805b" title="Failure. ">fstrm_res_failure</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
